# WanderLog äº‘ç«¯è¿ç§»æŠ€æœ¯æ–¹æ¡ˆ

## ä¸€ã€æ•´ä½“æ¶æ„è®¾è®¡

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                           Flutter App (Cç«¯)                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚  åœ°ç‚¹æµè§ˆ   â”‚  â”‚  åˆé›†å±•ç¤º   â”‚  â”‚  ç”¨æˆ·æ”¶è—   â”‚  â”‚  è´¦å·ç³»ç»Ÿ   â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
          â”‚                â”‚                â”‚                â”‚
          â–¼                â–¼                â–¼                â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        Supabase (åç«¯æœåŠ¡)                               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚                    PostgreSQL Database                           â”‚   â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚   â”‚
â”‚  â”‚  â”‚ places  â”‚ â”‚collectionsâ”‚ â”‚  users  â”‚ â”‚user_dataâ”‚ â”‚ configs â”‚   â”‚   â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                     â”‚
â”‚  â”‚  Auth       â”‚  â”‚  Edge Func  â”‚  â”‚  Realtime   â”‚                     â”‚
â”‚  â”‚  (è®¤è¯)     â”‚  â”‚  (API)      â”‚  â”‚  (å®æ—¶åŒæ­¥) â”‚                     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
          â”‚
          â”‚ å›¾ç‰‡ URL å¼•ç”¨
          â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Cloudflare (å›¾ç‰‡æœåŠ¡)                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚                    Cloudflare R2                                 â”‚   â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”‚   â”‚
â”‚  â”‚  â”‚ places/     â”‚  â”‚ collections/â”‚  â”‚ users/      â”‚              â”‚   â”‚
â”‚  â”‚  â”‚ (åœ°ç‚¹å›¾ç‰‡)  â”‚  â”‚ (åˆé›†å°é¢)  â”‚  â”‚ (ç”¨æˆ·å¤´åƒ)  â”‚              â”‚   â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚  Cloudflare Images (å¯é€‰) - å›¾ç‰‡å¤„ç†/å˜æ¢/CDN                    â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## äºŒã€æ•°æ®åˆ†ç±»ä¸å­˜å‚¨ç­–ç•¥

### 2.1 æ•°æ®åˆ†ç±»

| åœºæ™¯ | æ•°æ®ç±»å‹ | å­˜å‚¨ä½ç½® | è®¿é—®æƒé™ | åŒæ­¥ç­–ç•¥ |
|------|----------|----------|----------|----------|
| 1. å¹³å°åœ°ç‚¹ | Place + å›¾ç‰‡ | Supabase + R2 | å…¬å¼€è¯» | å•å‘æ¨é€ |
| 2. åˆé›†è¿è¥ | Collection + å°é¢ | Supabase + R2 | å…¬å¼€è¯» | å•å‘æ¨é€ |
| 3. ç”¨æˆ·è®°å½• | æ”¶è—/æ‰“å¡ | Supabase | ç”¨æˆ·ç§æœ‰ | åŒå‘åŒæ­¥ |
| 4. ç”¨æˆ·æ•°æ® | è´¦å·/ä¼šå‘˜ | Supabase Auth | ç”¨æˆ·ç§æœ‰ | å®æ—¶åŒæ­¥ |
| 5. é…ç½®æ•°æ® | App Config | Supabase | å…¬å¼€è¯» | æŒ‰éœ€æ‹‰å– |

### 2.2 Supabase æ•°æ®åº“è®¾è®¡

```sql
-- =====================================================
-- 1. åœ°ç‚¹æ•°æ® (å¹³å°è¿è¥ + AI è¯†åˆ«)
-- =====================================================
CREATE TABLE places (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name TEXT NOT NULL,
  city TEXT,
  country TEXT,
  latitude DOUBLE PRECISION NOT NULL,
  longitude DOUBLE PRECISION NOT NULL,
  address TEXT,
  description TEXT,
  opening_hours TEXT,
  rating DECIMAL(2,1),
  rating_count INTEGER,
  category TEXT,
  
  -- AI è¯†åˆ«å­—æ®µ
  ai_summary TEXT,
  ai_description TEXT,
  ai_tags JSONB DEFAULT '[]',
  
  -- å›¾ç‰‡ (å­˜å‚¨ Cloudflare R2 URL)
  cover_image TEXT,
  images JSONB DEFAULT '[]',
  
  -- æ‰©å±•ä¿¡æ¯
  price_level INTEGER,
  website TEXT,
  phone_number TEXT,
  google_place_id TEXT UNIQUE,
  
  -- æ¥æºè¿½è¸ª
  source TEXT DEFAULT 'google_maps',
  source_details JSONB,
  is_verified BOOLEAN DEFAULT false,
  
  -- æ—¶é—´æˆ³
  last_synced_at TIMESTAMPTZ,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- ç´¢å¼•ä¼˜åŒ–
CREATE INDEX idx_places_city ON places(city);
CREATE INDEX idx_places_category ON places(category);
CREATE INDEX idx_places_rating ON places(rating DESC);
CREATE INDEX idx_places_location ON places USING GIST (
  ST_SetSRID(ST_MakePoint(longitude, latitude), 4326)
);

-- =====================================================
-- 2. åˆé›†æ•°æ® (å¹³å°è¿è¥)
-- =====================================================
CREATE TABLE collections (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name TEXT NOT NULL,
  cover_image TEXT NOT NULL,  -- R2 URL
  description TEXT,
  people TEXT,                 -- ç›¸å…³äººç‰©
  works TEXT,                  -- ç›¸å…³ä½œå“
  source TEXT,
  
  -- å‘å¸ƒçŠ¶æ€
  is_published BOOLEAN DEFAULT false,
  published_at TIMESTAMPTZ,
  
  -- æ’åºæƒé‡
  sort_order INTEGER DEFAULT 0,
  
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- åˆé›†-åœ°ç‚¹å…³è”
CREATE TABLE collection_spots (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  collection_id UUID REFERENCES collections(id) ON DELETE CASCADE,
  place_id UUID REFERENCES places(id) ON DELETE CASCADE,
  city TEXT,
  sort_order INTEGER DEFAULT 0,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  
  UNIQUE(collection_id, place_id)
);

-- åˆé›†æ¨èåˆ†ç»„
CREATE TABLE collection_recommendations (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name TEXT NOT NULL,
  sort_order INTEGER DEFAULT 0,
  is_active BOOLEAN DEFAULT true,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- æ¨è-åˆé›†å…³è”
CREATE TABLE collection_recommendation_items (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  recommendation_id UUID REFERENCES collection_recommendations(id) ON DELETE CASCADE,
  collection_id UUID REFERENCES collections(id) ON DELETE CASCADE,
  sort_order INTEGER DEFAULT 0,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  
  UNIQUE(recommendation_id, collection_id)
);

-- =====================================================
-- 3. ç”¨æˆ·æ•°æ® (ä½¿ç”¨ Supabase Auth)
-- =====================================================
-- Supabase Auth è‡ªåŠ¨åˆ›å»º auth.users è¡¨
-- æ‰©å±•ç”¨æˆ·ä¿¡æ¯å­˜å‚¨åœ¨ public.profiles

CREATE TABLE profiles (
  id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  email TEXT,
  name TEXT,
  avatar_url TEXT,           -- R2 URL
  
  -- ä¼šå‘˜ä¿¡æ¯
  membership_type TEXT DEFAULT 'free',  -- free, premium, pro
  membership_expires_at TIMESTAMPTZ,
  
  -- ç»Ÿè®¡
  total_favorites INTEGER DEFAULT 0,
  total_checkins INTEGER DEFAULT 0,
  
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- ç”¨æˆ·æ”¶è—
CREATE TABLE user_favorites (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  place_id UUID REFERENCES places(id) ON DELETE CASCADE,
  notes TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  
  UNIQUE(user_id, place_id)
);

-- ç”¨æˆ·æ‰“å¡
CREATE TABLE user_checkins (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  place_id UUID REFERENCES places(id) ON DELETE CASCADE,
  visited_at TIMESTAMPTZ DEFAULT NOW(),
  rating INTEGER CHECK (rating >= 1 AND rating <= 5),
  notes TEXT,
  photos JSONB DEFAULT '[]',  -- R2 URLs
  is_public BOOLEAN DEFAULT false,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- ç”¨æˆ·åˆé›†æ”¶è—
CREATE TABLE user_collection_favorites (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  collection_id UUID REFERENCES collections(id) ON DELETE CASCADE,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  
  UNIQUE(user_id, collection_id)
);

-- ç´¢å¼•
CREATE INDEX idx_user_favorites_user ON user_favorites(user_id);
CREATE INDEX idx_user_checkins_user ON user_checkins(user_id);
CREATE INDEX idx_user_checkins_place ON user_checkins(place_id);

-- =====================================================
-- 4. é…ç½®æ•°æ®
-- =====================================================
CREATE TABLE app_configs (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  key TEXT UNIQUE NOT NULL,
  value JSONB NOT NULL,
  description TEXT,
  is_public BOOLEAN DEFAULT true,  -- æ˜¯å¦å¯¹ C ç«¯å¯è§
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- é¢„ç½®é…ç½®ç¤ºä¾‹
INSERT INTO app_configs (key, value, description, is_public) VALUES
('app_version', '{"min": "1.0.0", "latest": "1.2.0", "force_update": false}', 'ç‰ˆæœ¬æ§åˆ¶', true),
('feature_flags', '{"ai_recognition": true, "premium_features": true}', 'åŠŸèƒ½å¼€å…³', true),
('categories', '["é¤å…", "å’–å•¡é¦†", "æ™¯ç‚¹", "è´­ç‰©", "é…’åº—", "é…’å§"]', 'åœ°ç‚¹åˆ†ç±»', true),
('home_banners', '[]', 'é¦–é¡µè½®æ’­å›¾', true);

-- =====================================================
-- 5. RLS (Row Level Security) ç­–ç•¥
-- =====================================================

-- å¯ç”¨ RLS
ALTER TABLE places ENABLE ROW LEVEL SECURITY;
ALTER TABLE collections ENABLE ROW LEVEL SECURITY;
ALTER TABLE profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE user_favorites ENABLE ROW LEVEL SECURITY;
ALTER TABLE user_checkins ENABLE ROW LEVEL SECURITY;
ALTER TABLE app_configs ENABLE ROW LEVEL SECURITY;

-- å…¬å¼€æ•°æ®ç­–ç•¥ (places, collections, configs)
CREATE POLICY "Places are viewable by everyone" ON places
  FOR SELECT USING (true);

CREATE POLICY "Published collections are viewable" ON collections
  FOR SELECT USING (is_published = true);

CREATE POLICY "Public configs are viewable" ON app_configs
  FOR SELECT USING (is_public = true);

-- ç”¨æˆ·æ•°æ®ç­–ç•¥
CREATE POLICY "Users can view own profile" ON profiles
  FOR SELECT USING (auth.uid() = id);

CREATE POLICY "Users can update own profile" ON profiles
  FOR UPDATE USING (auth.uid() = id);

CREATE POLICY "Users can manage own favorites" ON user_favorites
  FOR ALL USING (auth.uid() = user_id);

CREATE POLICY "Users can manage own checkins" ON user_checkins
  FOR ALL USING (auth.uid() = user_id);

CREATE POLICY "Public checkins are viewable" ON user_checkins
  FOR SELECT USING (is_public = true);
```

## ä¸‰ã€Cloudflare R2 å›¾ç‰‡å­˜å‚¨è®¾è®¡

### 3.1 å­˜å‚¨æ¡¶ç»“æ„

```
wanderlog-images/
â”œâ”€â”€ places/
â”‚   â”œâ”€â”€ covers/           # åœ°ç‚¹å°é¢å›¾
â”‚   â”‚   â””â”€â”€ {place_id}.jpg
â”‚   â””â”€â”€ gallery/          # åœ°ç‚¹å›¾é›†
â”‚       â””â”€â”€ {place_id}/
â”‚           â”œâ”€â”€ 1.jpg
â”‚           â”œâ”€â”€ 2.jpg
â”‚           â””â”€â”€ ...
â”œâ”€â”€ collections/
â”‚   â””â”€â”€ covers/           # åˆé›†å°é¢
â”‚       â””â”€â”€ {collection_id}.jpg
â”œâ”€â”€ users/
â”‚   â”œâ”€â”€ avatars/          # ç”¨æˆ·å¤´åƒ
â”‚   â”‚   â””â”€â”€ {user_id}.jpg
â”‚   â””â”€â”€ checkins/         # æ‰“å¡ç…§ç‰‡
â”‚       â””â”€â”€ {user_id}/
â”‚           â””â”€â”€ {checkin_id}/
â”‚               â”œâ”€â”€ 1.jpg
â”‚               â””â”€â”€ ...
â””â”€â”€ system/
    â””â”€â”€ banners/          # ç³»ç»Ÿè½®æ’­å›¾
        â””â”€â”€ {banner_id}.jpg
```

### 3.2 Cloudflare Worker (å›¾ç‰‡ä¸Šä¼  API)

```typescript
// workers/image-upload.ts
export interface Env {
  WANDERLOG_IMAGES: R2Bucket;
  UPLOAD_SECRET: string;
}

export default {
  async fetch(request: Request, env: Env): Promise<Response> {
    const url = new URL(request.url);
    
    // CORS
    if (request.method === 'OPTIONS') {
      return new Response(null, {
        headers: {
          'Access-Control-Allow-Origin': '*',
          'Access-Control-Allow-Methods': 'GET, PUT, DELETE',
          'Access-Control-Allow-Headers': 'Content-Type, Authorization',
        },
      });
    }

    // éªŒè¯ä¸Šä¼ æƒé™
    const authHeader = request.headers.get('Authorization');
    if (request.method !== 'GET' && authHeader !== `Bearer ${env.UPLOAD_SECRET}`) {
      return new Response('Unauthorized', { status: 401 });
    }

    const key = url.pathname.slice(1); // ç§»é™¤å¼€å¤´çš„ /

    switch (request.method) {
      case 'PUT': {
        // ä¸Šä¼ å›¾ç‰‡
        const contentType = request.headers.get('Content-Type') || 'image/jpeg';
        await env.WANDERLOG_IMAGES.put(key, request.body, {
          httpMetadata: { contentType },
        });
        
        return new Response(JSON.stringify({ 
          success: true, 
          url: `https://images.wanderlog.app/${key}` 
        }), {
          headers: { 'Content-Type': 'application/json' },
        });
      }

      case 'GET': {
        // è·å–å›¾ç‰‡
        const object = await env.WANDERLOG_IMAGES.get(key);
        if (!object) {
          return new Response('Not Found', { status: 404 });
        }
        
        const headers = new Headers();
        headers.set('Content-Type', object.httpMetadata?.contentType || 'image/jpeg');
        headers.set('Cache-Control', 'public, max-age=31536000'); // 1å¹´ç¼“å­˜
        
        return new Response(object.body, { headers });
      }

      case 'DELETE': {
        await env.WANDERLOG_IMAGES.delete(key);
        return new Response(JSON.stringify({ success: true }));
      }

      default:
        return new Response('Method Not Allowed', { status: 405 });
    }
  },
};
```

### 3.3 å›¾ç‰‡å¤„ç†ç­–ç•¥

```typescript
// ä½¿ç”¨ Cloudflare Images æˆ–è‡ªå®šä¹‰ Worker å¤„ç†å›¾ç‰‡å˜æ¢
// URL æ ¼å¼: https://images.wanderlog.app/{path}?w=400&h=300&fit=cover

// æ”¯æŒçš„å‚æ•°:
// - w: å®½åº¦
// - h: é«˜åº¦  
// - fit: cover | contain | fill
// - q: è´¨é‡ (1-100)
// - f: æ ¼å¼ (webp | avif | jpeg)

// ç¤ºä¾‹:
// åŸå›¾: https://images.wanderlog.app/places/covers/abc123.jpg
// ç¼©ç•¥å›¾: https://images.wanderlog.app/places/covers/abc123.jpg?w=200&h=200&fit=cover
// WebP: https://images.wanderlog.app/places/covers/abc123.jpg?f=webp&q=80
```

## å››ã€æ•°æ®è¿ç§»æµç¨‹

### 4.1 è¿ç§»è„šæœ¬è®¾è®¡

```typescript
// scripts/migrate-to-supabase.ts
import { createClient } from '@supabase/supabase-js';
import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();
const supabase = createClient(
  process.env.SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_KEY! // ä½¿ç”¨ service key ç»•è¿‡ RLS
);

interface MigrationResult {
  table: string;
  total: number;
  migrated: number;
  failed: number;
  errors: string[];
}

// 1. è¿ç§»åœ°ç‚¹æ•°æ®
async function migratePlaces(): Promise<MigrationResult> {
  const result: MigrationResult = { 
    table: 'places', total: 0, migrated: 0, failed: 0, errors: [] 
  };
  
  const places = await prisma.place.findMany();
  result.total = places.length;
  
  for (const place of places) {
    try {
      // ä¸Šä¼ å›¾ç‰‡åˆ° R2
      const coverImageUrl = place.coverImage 
        ? await uploadImageToR2(place.coverImage, `places/covers/${place.id}`)
        : null;
      
      const imagesUrls = place.images 
        ? await uploadImagesToR2(JSON.parse(place.images), `places/gallery/${place.id}`)
        : [];

      // æ’å…¥ Supabase
      const { error } = await supabase.from('places').insert({
        id: place.id,
        name: place.name,
        city: place.city,
        country: place.country,
        latitude: place.latitude,
        longitude: place.longitude,
        address: place.address,
        description: place.description,
        opening_hours: place.openingHours,
        rating: place.rating,
        rating_count: place.ratingCount,
        category: place.category,
        ai_summary: place.aiSummary,
        ai_description: place.aiDescription,
        ai_tags: place.aiTags ? JSON.parse(place.aiTags) : [],
        cover_image: coverImageUrl,
        images: imagesUrls,
        price_level: place.priceLevel,
        website: place.website,
        phone_number: place.phoneNumber,
        google_place_id: place.googlePlaceId,
        source: place.source,
        source_details: place.sourceDetails ? JSON.parse(place.sourceDetails) : null,
        is_verified: place.isVerified,
        last_synced_at: place.lastSyncedAt,
        created_at: place.createdAt,
        updated_at: place.updatedAt,
      });

      if (error) throw error;
      result.migrated++;
    } catch (e: any) {
      result.failed++;
      result.errors.push(`Place ${place.id}: ${e.message}`);
    }
  }
  
  return result;
}

// 2. è¿ç§»åˆé›†æ•°æ®
async function migrateCollections(): Promise<MigrationResult> {
  const result: MigrationResult = { 
    table: 'collections', total: 0, migrated: 0, failed: 0, errors: [] 
  };
  
  const collections = await prisma.collection.findMany({
    include: { collectionSpots: true }
  });
  result.total = collections.length;
  
  for (const collection of collections) {
    try {
      const coverImageUrl = await uploadImageToR2(
        collection.coverImage, 
        `collections/covers/${collection.id}`
      );

      const { error } = await supabase.from('collections').insert({
        id: collection.id,
        name: collection.name,
        cover_image: coverImageUrl,
        description: collection.description,
        people: collection.people,
        works: collection.works,
        source: collection.source,
        is_published: collection.isPublished,
        published_at: collection.publishedAt,
        created_at: collection.createdAt,
        updated_at: collection.updatedAt,
      });

      if (error) throw error;

      // è¿ç§»åˆé›†-åœ°ç‚¹å…³è”
      for (const spot of collection.collectionSpots) {
        await supabase.from('collection_spots').insert({
          id: spot.id,
          collection_id: spot.collectionId,
          place_id: spot.placeId,
          city: spot.city,
          created_at: spot.createdAt,
        });
      }

      result.migrated++;
    } catch (e: any) {
      result.failed++;
      result.errors.push(`Collection ${collection.id}: ${e.message}`);
    }
  }
  
  return result;
}

// 3. è¿ç§»ç”¨æˆ·æ•°æ®
async function migrateUsers(): Promise<MigrationResult> {
  const result: MigrationResult = { 
    table: 'users', total: 0, migrated: 0, failed: 0, errors: [] 
  };
  
  const users = await prisma.user.findMany({
    include: { userCollections: true }
  });
  result.total = users.length;
  
  for (const user of users) {
    try {
      // åˆ›å»º Supabase Auth ç”¨æˆ·
      const { data: authUser, error: authError } = await supabase.auth.admin.createUser({
        email: user.email,
        email_confirm: user.isEmailVerified,
        user_metadata: {
          name: user.name,
          avatar_url: user.avatarUrl,
        },
      });

      if (authError) throw authError;

      // ä¸Šä¼ å¤´åƒ
      const avatarUrl = user.avatarUrl 
        ? await uploadImageToR2(user.avatarUrl, `users/avatars/${authUser.user.id}`)
        : null;

      // åˆ›å»º profile
      await supabase.from('profiles').insert({
        id: authUser.user.id,
        email: user.email,
        name: user.name,
        avatar_url: avatarUrl,
        created_at: user.createdAt,
        updated_at: user.updatedAt,
      });

      // è¿ç§»ç”¨æˆ·åˆé›†æ”¶è—
      for (const uc of user.userCollections) {
        await supabase.from('user_collection_favorites').insert({
          user_id: authUser.user.id,
          collection_id: uc.collectionId,
          created_at: uc.createdAt,
        });
      }

      result.migrated++;
    } catch (e: any) {
      result.failed++;
      result.errors.push(`User ${user.id}: ${e.message}`);
    }
  }
  
  return result;
}

// 4. å›¾ç‰‡ä¸Šä¼ å·¥å…·å‡½æ•°
async function uploadImageToR2(
  sourceUrl: string, 
  targetPath: string
): Promise<string> {
  // ä¸‹è½½åŸå›¾
  const response = await fetch(sourceUrl);
  const buffer = await response.arrayBuffer();
  
  // ä¸Šä¼ åˆ° R2
  const uploadResponse = await fetch(
    `https://images.wanderlog.app/${targetPath}.jpg`,
    {
      method: 'PUT',
      headers: {
        'Authorization': `Bearer ${process.env.R2_UPLOAD_SECRET}`,
        'Content-Type': 'image/jpeg',
      },
      body: buffer,
    }
  );
  
  const result = await uploadResponse.json();
  return result.url;
}

async function uploadImagesToR2(
  sourceUrls: string[], 
  basePath: string
): Promise<string[]> {
  const urls: string[] = [];
  for (let i = 0; i < sourceUrls.length; i++) {
    const url = await uploadImageToR2(sourceUrls[i], `${basePath}/${i + 1}`);
    urls.push(url);
  }
  return urls;
}

// 5. ä¸»è¿ç§»å‡½æ•°
async function runMigration() {
  console.log('ğŸš€ å¼€å§‹æ•°æ®è¿ç§»...\n');
  
  const results: MigrationResult[] = [];
  
  // æŒ‰é¡ºåºè¿ç§» (æœ‰å¤–é”®ä¾èµ–)
  console.log('ğŸ“ è¿ç§»åœ°ç‚¹æ•°æ®...');
  results.push(await migratePlaces());
  
  console.log('ğŸ“š è¿ç§»åˆé›†æ•°æ®...');
  results.push(await migrateCollections());
  
  console.log('ğŸ‘¤ è¿ç§»ç”¨æˆ·æ•°æ®...');
  results.push(await migrateUsers());
  
  console.log('ğŸ”— è¿ç§»æ¨èæ•°æ®...');
  results.push(await migrateRecommendations());
  
  // è¾“å‡ºæŠ¥å‘Š
  console.log('\nğŸ“Š è¿ç§»æŠ¥å‘Š:');
  console.log('='.repeat(50));
  for (const r of results) {
    console.log(`${r.table}: ${r.migrated}/${r.total} æˆåŠŸ, ${r.failed} å¤±è´¥`);
    if (r.errors.length > 0) {
      r.errors.forEach(e => console.log(`  âŒ ${e}`));
    }
  }
}

runMigration().catch(console.error);
```

## äº”ã€Flutter App é›†æˆ

### 5.1 Supabase å®¢æˆ·ç«¯é…ç½®

```dart
// lib/core/supabase/supabase_client.dart
import 'package:supabase_flutter/supabase_flutter.dart';

class SupabaseConfig {
  static const String url = 'https://your-project.supabase.co';
  static const String anonKey = 'your-anon-key';
  
  static Future<void> initialize() async {
    await Supabase.initialize(
      url: url,
      anonKey: anonKey,
      authOptions: const FlutterAuthClientOptions(
        authFlowType: AuthFlowType.pkce,
      ),
      realtimeClientOptions: const RealtimeClientOptions(
        logLevel: RealtimeLogLevel.info,
      ),
    );
  }
  
  static SupabaseClient get client => Supabase.instance.client;
  static GoTrueClient get auth => client.auth;
}
```

### 5.2 æ•°æ®ä»“åº“å±‚

```dart
// lib/services/repositories/place_repository.dart
import 'package:supabase_flutter/supabase_flutter.dart';

class PlaceRepository {
  final SupabaseClient _client;
  
  PlaceRepository(this._client);
  
  /// è·å–åœ°ç‚¹åˆ—è¡¨ (åˆ†é¡µ)
  Future<List<Place>> getPlaces({
    String? city,
    String? category,
    int page = 1,
    int pageSize = 20,
  }) async {
    var query = _client
        .from('places')
        .select()
        .order('rating', ascending: false);
    
    if (city != null) {
      query = query.eq('city', city);
    }
    if (category != null) {
      query = query.eq('category', category);
    }
    
    final response = await query
        .range((page - 1) * pageSize, page * pageSize - 1);
    
    return (response as List).map((e) => Place.fromJson(e)).toList();
  }
  
  /// æœç´¢åœ°ç‚¹
  Future<List<Place>> searchPlaces(String keyword) async {
    final response = await _client
        .from('places')
        .select()
        .or('name.ilike.%$keyword%,address.ilike.%$keyword%')
        .limit(20);
    
    return (response as List).map((e) => Place.fromJson(e)).toList();
  }
  
  /// è·å–é™„è¿‘åœ°ç‚¹
  Future<List<Place>> getNearbyPlaces(
    double lat, 
    double lng, 
    double radiusKm,
  ) async {
    // ä½¿ç”¨ PostGIS å‡½æ•°
    final response = await _client.rpc('get_nearby_places', params: {
      'lat': lat,
      'lng': lng,
      'radius_km': radiusKm,
    });
    
    return (response as List).map((e) => Place.fromJson(e)).toList();
  }
}

// lib/services/repositories/user_repository.dart
class UserRepository {
  final SupabaseClient _client;
  
  UserRepository(this._client);
  
  /// è·å–ç”¨æˆ·æ”¶è—
  Future<List<Place>> getFavorites() async {
    final userId = _client.auth.currentUser?.id;
    if (userId == null) throw Exception('Not authenticated');
    
    final response = await _client
        .from('user_favorites')
        .select('*, place:places(*)')
        .eq('user_id', userId)
        .order('created_at', ascending: false);
    
    return (response as List)
        .map((e) => Place.fromJson(e['place']))
        .toList();
  }
  
  /// æ·»åŠ æ”¶è—
  Future<void> addFavorite(String placeId) async {
    final userId = _client.auth.currentUser?.id;
    if (userId == null) throw Exception('Not authenticated');
    
    await _client.from('user_favorites').insert({
      'user_id': userId,
      'place_id': placeId,
    });
  }
  
  /// ç§»é™¤æ”¶è—
  Future<void> removeFavorite(String placeId) async {
    final userId = _client.auth.currentUser?.id;
    if (userId == null) throw Exception('Not authenticated');
    
    await _client
        .from('user_favorites')
        .delete()
        .eq('user_id', userId)
        .eq('place_id', placeId);
  }
  
  /// æ‰“å¡
  Future<void> checkin({
    required String placeId,
    int? rating,
    String? notes,
    List<String>? photoUrls,
  }) async {
    final userId = _client.auth.currentUser?.id;
    if (userId == null) throw Exception('Not authenticated');
    
    await _client.from('user_checkins').insert({
      'user_id': userId,
      'place_id': placeId,
      'rating': rating,
      'notes': notes,
      'photos': photoUrls ?? [],
    });
  }
}
```

### 5.3 è®¤è¯æœåŠ¡

```dart
// lib/services/auth_service.dart
class AuthService {
  final SupabaseClient _client;
  
  AuthService(this._client);
  
  User? get currentUser => _client.auth.currentUser;
  Stream<AuthState> get authStateChanges => _client.auth.onAuthStateChange;
  
  /// é‚®ç®±æ³¨å†Œ
  Future<AuthResponse> signUp(String email, String password) async {
    return await _client.auth.signUp(
      email: email,
      password: password,
    );
  }
  
  /// é‚®ç®±ç™»å½•
  Future<AuthResponse> signIn(String email, String password) async {
    return await _client.auth.signInWithPassword(
      email: email,
      password: password,
    );
  }
  
  /// Google ç™»å½•
  Future<AuthResponse> signInWithGoogle() async {
    return await _client.auth.signInWithOAuth(
      OAuthProvider.google,
      redirectTo: 'io.wanderlog.app://login-callback',
    );
  }
  
  /// Apple ç™»å½•
  Future<AuthResponse> signInWithApple() async {
    return await _client.auth.signInWithOAuth(
      OAuthProvider.apple,
      redirectTo: 'io.wanderlog.app://login-callback',
    );
  }
  
  /// ç™»å‡º
  Future<void> signOut() async {
    await _client.auth.signOut();
  }
}
```

### 5.4 å›¾ç‰‡ä¸Šä¼ æœåŠ¡

```dart
// lib/services/image_service.dart
import 'dart:io';
import 'package:http/http.dart' as http;

class ImageService {
  static const String _baseUrl = 'https://images.wanderlog.app';
  
  /// ä¸Šä¼ ç”¨æˆ·å¤´åƒ
  Future<String> uploadAvatar(File imageFile) async {
    final userId = SupabaseConfig.client.auth.currentUser?.id;
    if (userId == null) throw Exception('Not authenticated');
    
    final path = 'users/avatars/$userId.jpg';
    return await _uploadImage(imageFile, path);
  }
  
  /// ä¸Šä¼ æ‰“å¡ç…§ç‰‡
  Future<List<String>> uploadCheckinPhotos(
    String checkinId, 
    List<File> images,
  ) async {
    final userId = SupabaseConfig.client.auth.currentUser?.id;
    if (userId == null) throw Exception('Not authenticated');
    
    final urls = <String>[];
    for (int i = 0; i < images.length; i++) {
      final path = 'users/checkins/$userId/$checkinId/${i + 1}.jpg';
      final url = await _uploadImage(images[i], path);
      urls.add(url);
    }
    return urls;
  }
  
  Future<String> _uploadImage(File file, String path) async {
    final bytes = await file.readAsBytes();
    
    final response = await http.put(
      Uri.parse('$_baseUrl/$path'),
      headers: {
        'Content-Type': 'image/jpeg',
        'Authorization': 'Bearer ${await _getUploadToken()}',
      },
      body: bytes,
    );
    
    if (response.statusCode != 200) {
      throw Exception('Upload failed: ${response.body}');
    }
    
    return '$_baseUrl/$path';
  }
  
  Future<String> _getUploadToken() async {
    // ä» Supabase Edge Function è·å–ä¸´æ—¶ä¸Šä¼  token
    final response = await SupabaseConfig.client.functions.invoke(
      'get-upload-token',
    );
    return response.data['token'];
  }
  
  /// è·å–ä¼˜åŒ–åçš„å›¾ç‰‡ URL
  static String getOptimizedUrl(
    String originalUrl, {
    int? width,
    int? height,
    String fit = 'cover',
    int quality = 80,
  }) {
    final params = <String>[];
    if (width != null) params.add('w=$width');
    if (height != null) params.add('h=$height');
    params.add('fit=$fit');
    params.add('q=$quality');
    params.add('f=webp');
    
    return '$originalUrl?${params.join('&')}';
  }
}
```

## å…­ã€Supabase Edge Functions (API å±‚)

### 6.1 è·å–ä¸Šä¼  Token

```typescript
// supabase/functions/get-upload-token/index.ts
import { serve } from 'https://deno.land/std@0.168.0/http/server.ts'
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2'
import { SignJWT } from 'https://deno.land/x/jose@v4.14.4/index.ts'

serve(async (req) => {
  // éªŒè¯ç”¨æˆ·èº«ä»½
  const authHeader = req.headers.get('Authorization')!
  const supabase = createClient(
    Deno.env.get('SUPABASE_URL')!,
    Deno.env.get('SUPABASE_ANON_KEY')!,
    { global: { headers: { Authorization: authHeader } } }
  )
  
  const { data: { user }, error } = await supabase.auth.getUser()
  if (error || !user) {
    return new Response(JSON.stringify({ error: 'Unauthorized' }), { 
      status: 401 
    })
  }
  
  // ç”Ÿæˆä¸´æ—¶ä¸Šä¼  token (15åˆ†é’Ÿæœ‰æ•ˆ)
  const secret = new TextEncoder().encode(Deno.env.get('R2_UPLOAD_SECRET')!)
  const token = await new SignJWT({ userId: user.id })
    .setProtectedHeader({ alg: 'HS256' })
    .setExpirationTime('15m')
    .sign(secret)
  
  return new Response(JSON.stringify({ token }), {
    headers: { 'Content-Type': 'application/json' },
  })
})
```

### 6.2 é™„è¿‘åœ°ç‚¹æŸ¥è¯¢ (PostGIS)

```sql
-- åˆ›å»º PostGIS å‡½æ•°
CREATE OR REPLACE FUNCTION get_nearby_places(
  lat DOUBLE PRECISION,
  lng DOUBLE PRECISION,
  radius_km DOUBLE PRECISION DEFAULT 5
)
RETURNS SETOF places AS $$
BEGIN
  RETURN QUERY
  SELECT *
  FROM places
  WHERE ST_DWithin(
    ST_SetSRID(ST_MakePoint(longitude, latitude), 4326)::geography,
    ST_SetSRID(ST_MakePoint(lng, lat), 4326)::geography,
    radius_km * 1000  -- è½¬æ¢ä¸ºç±³
  )
  ORDER BY ST_Distance(
    ST_SetSRID(ST_MakePoint(longitude, latitude), 4326)::geography,
    ST_SetSRID(ST_MakePoint(lng, lat), 4326)::geography
  );
END;
$$ LANGUAGE plpgsql;
```

## ä¸ƒã€å®æ–½æ­¥éª¤

### Phase 1: åŸºç¡€è®¾æ–½æ­å»º (1-2å¤©)

```bash
# 1. åˆ›å»º Supabase é¡¹ç›®
# è®¿é—® https://supabase.com/dashboard åˆ›å»ºæ–°é¡¹ç›®

# 2. åˆ›å»º Cloudflare R2 å­˜å‚¨æ¡¶
# è®¿é—® https://dash.cloudflare.com â†’ R2 â†’ Create bucket
# åç§°: wanderlog-images

# 3. éƒ¨ç½² Cloudflare Worker
cd workers
wrangler publish

# 4. é…ç½®è‡ªå®šä¹‰åŸŸå
# R2: images.wanderlog.app
# Supabase: api.wanderlog.app (å¯é€‰)
```

### Phase 2: æ•°æ®åº“è¿ç§» (1å¤©)

```bash
# 1. åœ¨ Supabase æ‰§è¡Œå»ºè¡¨ SQL
# å¤åˆ¶ä¸Šé¢çš„ SQL åˆ° Supabase SQL Editor æ‰§è¡Œ

# 2. å¯ç”¨ PostGIS æ‰©å±•
CREATE EXTENSION IF NOT EXISTS postgis;

# 3. è¿è¡Œè¿ç§»è„šæœ¬
cd wanderlog_api
npx ts-node scripts/migrate-to-supabase.ts

# 4. éªŒè¯æ•°æ®
SELECT COUNT(*) FROM places;
SELECT COUNT(*) FROM collections;
SELECT COUNT(*) FROM profiles;
```

### Phase 3: Flutter App æ”¹é€  (2-3å¤©)

```yaml
# pubspec.yaml æ·»åŠ ä¾èµ–
dependencies:
  supabase_flutter: ^2.3.0
  cached_network_image: ^3.3.0
```

```dart
// 1. åˆå§‹åŒ– Supabase
void main() async {
  WidgetsFlutterBinding.ensureInitialized();
  await SupabaseConfig.initialize();
  runApp(MyApp());
}

// 2. æ›¿æ¢ç°æœ‰ API è°ƒç”¨ä¸º Supabase è°ƒç”¨
// 3. æ›´æ–°å›¾ç‰‡ URL ä¸º R2 URL
// 4. æµ‹è¯•æ‰€æœ‰åŠŸèƒ½
```

### Phase 4: æµ‹è¯•ä¸ä¸Šçº¿ (1-2å¤©)

```bash
# 1. åŠŸèƒ½æµ‹è¯•æ¸…å•
- [ ] åœ°ç‚¹åˆ—è¡¨åŠ è½½
- [ ] åœ°ç‚¹æœç´¢
- [ ] åˆé›†å±•ç¤º
- [ ] ç”¨æˆ·æ³¨å†Œ/ç™»å½•
- [ ] Google/Apple ç™»å½•
- [ ] æ”¶è—åŠŸèƒ½
- [ ] æ‰“å¡åŠŸèƒ½
- [ ] å›¾ç‰‡ä¸Šä¼ 
- [ ] å›¾ç‰‡åŠ è½½

# 2. æ€§èƒ½æµ‹è¯•
- [ ] é¦–å±åŠ è½½æ—¶é—´ < 2s
- [ ] å›¾ç‰‡åŠ è½½æ—¶é—´ < 1s
- [ ] API å“åº”æ—¶é—´ < 500ms

# 3. ä¸Šçº¿
- é…ç½®ç”Ÿäº§ç¯å¢ƒå˜é‡
- åˆ‡æ¢ App åˆ°ç”Ÿäº§ Supabase
- ç›‘æ§é”™è¯¯æ—¥å¿—
```

## å…«ã€ç¯å¢ƒå˜é‡é…ç½®

### 8.1 åç«¯ (.env)

```bash
# Supabase
SUPABASE_URL=https://your-project.supabase.co
SUPABASE_ANON_KEY=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
SUPABASE_SERVICE_KEY=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...

# Cloudflare R2
R2_ACCOUNT_ID=your-account-id
R2_ACCESS_KEY_ID=your-access-key
R2_SECRET_ACCESS_KEY=your-secret-key
R2_BUCKET_NAME=wanderlog-images
R2_PUBLIC_URL=https://images.wanderlog.app
R2_UPLOAD_SECRET=your-upload-secret
```

### 8.2 Flutter App (.env)

```bash
# Supabase
SUPABASE_URL=https://your-project.supabase.co
SUPABASE_ANON_KEY=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...

# Cloudflare Images
IMAGES_BASE_URL=https://images.wanderlog.app
```

### 8.3 Cloudflare Worker (wrangler.toml)

```toml
name = "wanderlog-images"
main = "src/index.ts"
compatibility_date = "2024-01-01"

[[r2_buckets]]
binding = "WANDERLOG_IMAGES"
bucket_name = "wanderlog-images"

[vars]
UPLOAD_SECRET = "your-upload-secret"
```

## ä¹ã€æˆæœ¬ä¼°ç®—

| æœåŠ¡ | å…è´¹é¢åº¦ | é¢„ä¼°æœˆè´¹ç”¨ |
|------|----------|------------|
| Supabase (Free) | 500MB æ•°æ®åº“, 1GB å­˜å‚¨ | $0 |
| Supabase (Pro) | 8GB æ•°æ®åº“, 100GB å­˜å‚¨ | $25/æœˆ |
| Cloudflare R2 | 10GB å­˜å‚¨, 100ä¸‡æ¬¡è¯·æ±‚ | $0 |
| Cloudflare R2 (è¶…å‡º) | - | $0.015/GB |
| Cloudflare Workers | 10ä¸‡æ¬¡/å¤© | $0 |

åˆæœŸå»ºè®®: ä½¿ç”¨ Supabase Free + Cloudflare R2 Freeï¼Œè¶³å¤Ÿæ”¯æ’‘æ—©æœŸç”¨æˆ·ã€‚

## åã€åç»­ä¼˜åŒ–å»ºè®®

1. **ç¼“å­˜ç­–ç•¥**: ä½¿ç”¨ Cloudflare CDN ç¼“å­˜çƒ­é—¨æ•°æ®
2. **å®æ—¶åŒæ­¥**: åˆ©ç”¨ Supabase Realtime å®ç°æ”¶è—/æ‰“å¡å®æ—¶æ›´æ–°
3. **ç¦»çº¿æ”¯æŒ**: ä½¿ç”¨ Hive/Isar æœ¬åœ°ç¼“å­˜ï¼Œæ”¯æŒç¦»çº¿æµè§ˆ
4. **å›¾ç‰‡ä¼˜åŒ–**: ä½¿ç”¨ Cloudflare Images è‡ªåŠ¨ç”Ÿæˆå¤šå°ºå¯¸å›¾ç‰‡
5. **ç›‘æ§å‘Šè­¦**: é…ç½® Supabase ç›‘æ§ + Cloudflare Analytics
